#!/usr/bin/env Rscript
# ===================================================================
# eSLAC Preprocessing & Analysis (MSR-seq Input)
# Author: Mahdi Assari
# GitHub: https://github.com/mahdiassari2/eSLAC
# License: MIT
# ===================================================================
# Purpose:
#   1) Validate environment & packages
#   2) Load tRNA modification reference
#   3) Index TSV/count files & map to conditions
#   4) Parallel read of basewise and count data
#   5) Compute counts, percentages, charging ratios
#   6) Isoacceptor & isodecoder aggregation
#   7) Volcano plot generation
#   8) Output results
# ===================================================================

# =========================
# 0. Packages
# =========================
suppressPackageStartupMessages({
  required_packages <- c(
    "tidyverse", "data.table", "foreach", "doParallel", "readxl",
    "gridExtra", "ggpubr", "stringr", "ggrepel", "writexl", "iterators"
  )
})

missing_packages <- setdiff(required_packages, rownames(installed.packages()))
if(length(missing_packages) > 0){
  stop(paste0("Missing packages: ", paste(missing_packages, collapse=", "),
              "\nInstall in Conda: conda install -n rstudio_env ..."))
}

invisible(lapply(required_packages, library, character.only = TRUE))
message("✅ Required packages loaded successfully.")

# =========================
# 1. User-defined parameters
# =========================
samplenumlist <- 1:22
mutdellim <- 5

# Example conditions (customize for experiment)
conditions <- c(
  "(1)WT-NT_rep1","(2)WT-NT_rep2","(3)WT-BStreated_rep1",
  "(4)WT-BStreated_rep2","(5)WT-PBtreated_rep1","WT-_PBtreated_rep2",
  "(7)PUS1KO-BStreated_rep1","(8)PUS1KO-BStreated_rep2","(9)PUS1KO-BStreated_rep3",
  "(10)TRUB1KO-BStreated_rep1","(11)TRUB1KO-BStreated_rep2","(12)PUS7KO-BStreated_rep1",
  "(13)PUS7KO-BStreated_rep2","(14)PUS7KO-BStreated_rep3","(15)Polysome-NT_rep1",
  "(16)Polysome-NT_rep2","(17)Polysome-BStreated_rep1","(18)Polysome-BStreated_rep2",
  "(19)Inp-NT_rep1","(20)Inp-NT_rep2","(21)Inp-BStreated_rep1","(22)Inp-BStreated_rep2"
)

# =========================
# 2. Paths
# =========================
base_path <- "/project/taopan/mahdi"
paths <- list(
  counts   = file.path(base_path, "6_sam_counter"),
  tsv      = file.path(base_path, "5_tsv"),
  sinmol   = file.path(base_path, "sinmol"),
  project  = "MA-13-456-epichemcross",
  ref      = "hg38_tRNA_Panlab"
)
PATH_5_tsv   <- file.path(paths$tsv, paths$project, paths$ref)
PATH_C       <- file.path(paths$counts, paths$project, paths$ref)
PATH_SinMol  <- file.path(paths$sinmol, paths$project)
output_dir   <- file.path(base_path, "plots", paths$project)
dir.create(output_dir, showWarnings=FALSE, recursive=TRUE)

# =========================
# 3. Parallel setup
# =========================
n_cores <- max(1, parallel::detectCores()-1)
data.table::setDTthreads(n_cores)

# =========================
# 4. Utility functions
# =========================
`%nin%` <- Negate(`%in%`)

stop_if_missing_dir <- function(p){ if(!dir.exists(p)) stop(paste0("Path not found: ",p), call.=FALSE) }
stop_if_missing_file <- function(p){ if(!file.exists(p)) stop(paste0("File not found: ",p), call.=FALSE) }

index_files <- function(base_path){
  stop_if_missing_dir(base_path)
  tibble(file_name = list.files(base_path)) |>
    filter((str_detect(file_name,"\\.tsv$") | str_detect(file_name,"\\.txt$")),
           !str_detect(file_name,"unassigned")) |>
    mutate(file_name2 = sub("(.*)\\.(tsv|txt)$","\\1",file_name)) |>
    separate(file_name2, into=c("sample","replicate","binstart","binstop","junk"),
             sep="_", remove=TRUE, fill="right") |>
    select(file_name, sample, replicate, binstart, binstop)
}

read_tsv_selected <- function(row, base_path, selected_columns){
  fp <- file.path(base_path, row$file_name)
  dt <- data.table::fread(fp, sep="\t", showProgress=FALSE)
  missing_cols <- setdiff(selected_columns, names(dt))
  if(length(missing_cols)>0) stop(paste0("Missing columns: ", paste(missing_cols, collapse=", ")))
  dt <- dt[, ..selected_columns]
  dt[, `:=`(sample=row$sample, replicate=row$replicate, binstart=row$binstart, binstop=row$binstop)]
  dt
}

# =========================
# 5. Load & index TSV/count files
# =========================
FILES   <- index_files(PATH_5_tsv) |> mutate(binstart=ifelse(is.na(binstart),-3,binstart),
                                              binstop=ifelse(is.na(binstop),-3,binstop))
FILES_C <- index_files(PATH_C)   |> mutate(binstart=ifelse(is.na(binstart),-3,binstart),
                                           binstop=ifelse(is.na(binstop),-3,binstop))

# =========================
# 6. Parallel read of TSVs
# =========================
selected_cols_t <- c("gene","position","base","pileup","deletion","mutation","insertion","A","C","G","T","N")
selected_cols_c <- c("name","count")

cl <- parallel::makeCluster(n_cores)
doParallel::registerDoParallel(cl)

FILES_oneS <- FILES |> filter(substr(sample,2,2) %in% samplenumlist) |> as.data.table()
hg38_tRNA_t <- foreach::foreach(row=iter(FILES_oneS, by="row"), .packages="data.table") %dopar% {
  read_tsv_selected(row, PATH_5_tsv, selected_cols_t)
} |> data.table::rbindlist(use.names=TRUE, fill=TRUE)

FILES_oneS_C <- FILES_C |> filter(substr(sample,2,2) %in% samplenumlist) |> as.data.table()
hg38_tRNA_c <- foreach::foreach(row=iter(FILES_oneS_C, by="row"), .packages="data.table") %dopar% {
  fp <- file.path(PATH_C,row$file_name)
  dt <- data.table::fread(fp, sep="\t", showProgress=FALSE)
  dt <- dt[, ..selected_cols_c]
  dt[, `:=`(sample=row$sample, replicate=row$replicate, binstart=row$binstart, binstop=row$binstop)]
  dt
} |> data.table::rbindlist(use.names=TRUE, fill=TRUE)

data.table::setnames(hg38_tRNA_c,"name","gene")
parallel::stopCluster(cl)

# =========================
# 7. Merge basewise + counts & filter non-tRNA
# =========================
hg38_tRNA_tc <- merge(
  hg38_tRNA_t,
  hg38_tRNA_c[,.(gene,sample,replicate,binstart,binstop,count)],
  by=c("gene","sample","replicate","binstart","binstop"),
  all.x=TRUE, allow.cartesian=TRUE
)

# Remove rRNA, snoRNA, and spike-ins
hg38_tRNA_tRNA <- hg38_tRNA_tc[
  gene %nin% c("NR_004394.1","NR_002716.3","NR_003925.1","NR_004430.2",
               "NR_002756.2","NR_004391.1","NR_004392.1","NR_004393.1",
               "NR_001571.2","Homo_sapiens_chrX.rRNA-5SR5SR","Homo_sapiens_chrX.rRNA-58S58S",
               "Ecoli_Tyr","Yeast_Phe","Ecoli_Lys",
               "spikein_SCC1","spikein_SCCA1","spikein_SCCA2","spikein_SCCA3")]

# =========================
# 8. Isoacceptor / isodecoder counts & percentages
# =========================
hg38_tRNA_tRNA[, c("AA","anticodon","N1","N2") := tstrsplit(gene, "-", fixed=TRUE)]
hg38_tRNA_tRNA[, AA_anticodon := paste(AA, anticodon, sep="-")]
hg38_tRNA_tRNA[, source := ifelse(substr(gene,1,2)=="mt","mitochondrial","cytosolic")]
data.table::setnames(hg38_tRNA_tRNA,"replicate","rep")

# Compute per-rep and per-sample percentages
temp_count <- hg38_tRNA_tRNA[, .(
  tRNA_gene_count_per_rep = sum(count),
  tRNA_gene_count_all_rep = sum(count)
), by=.(sample, rep, gene, binstart, binstop)]
temp_count[, tRNA_gene_percent_per_rep := tRNA_gene_count_per_rep / sum(tRNA_gene_count_per_rep) * 100, by=.(sample, rep)]
temp_count[, tRNA_gene_percent_all_rep := tRNA_gene_count_all_rep / sum(tRNA_gene_count_all_rep) * 100, by=.(sample)]

# =========================
# 9. Charging computation (ACC at 5' end)
# =========================
temp_correct_proc <- copy(hg38_tRNA_tRNA)
temp_correct_proc[, delrate := deletion/pmax(pileup,1)]
temp_correct_proc[, delrate_avg := mean(delrate), by=.(sample, binstart, AA_anticodon)]
temp_correct_proc[, valid_charging := fifelse(substr(base,1,3)=="ACC","yes","no"), by=.(sample, binstart, AA_anticodon, rep)]

temp_charging <- temp_correct_proc[valid_charging=="yes",
                                   .(charging_ratio= pileup[1]/pmax(pileup[2],1)),
                                   by=.(sample, binstart, AA_anticodon, rep)]
temp_charging <- temp_charging[, .(
  charging_ratio_avg=mean(charging_ratio, na.rm=TRUE),
  charging_ratio_sd=sd(charging_ratio, na.rm=TRUE)
), by=.(sample, AA_anticodon)]

# =========================
# 10. Volcano Plot
# =========================
temp_volcano <- copy(temp_correct_proc)
temp_volcano[, totalSumCounts := sum(count), by=.(sample, rep)]
temp_volcano[, AASumCounts := sum(count), by=.(sample, rep, AA_anticodon)]
temp_volcano[, rpm := AASumCounts/pmax(totalSumCounts,1)]

# Example comparison between two groups
group1 <- "4)"; group2 <- "20)"
temp_volcano_norep <- temp_volcano[str_sub(sample,2,3) %in% c(group1, group2)]
temp_volcano_norep[, meanRPM := mean(rpm), by=.(sample, gene)]

# t-test per gene
temp_volcano_ttest <- temp_volcano[str_sub(sample,2,3) %in% c(group1, group2)][,
  if(length(unique(sample))==2 & all(table(sample)>=2)) .(p.value=t.test(rpm ~ sample)$p.value) else .(p.value=NA_real_), by=gene
]
temp_volcano_ttest[, p.adj := p.adjust(p.value, method="BH")]

# Merge meanRPM + p-values + compute logFC
merged <- temp_volcano_norep[, .(meanRPM=mean(meanRPM)), by=.(sample,gene)]
merged <- merge(merged, temp_volcano_ttest, by="gene")
merged[, logFC := log2((!!sym(names(.)[2])+1e-9)/(!!sym(names(.)[3])+1e-9))]

# Volcano plot
p <- ggplot(merged, aes(x=logFC, y=-log10(p.adj))) +
  geom_point(size=2, alpha=0.5) +
  geom_vline(xintercept=c(-1.5,1.5), lty=2) +
  geom_hline(yintercept=-log10(0.05), lty=2) +
  labs(x="log2(Fold Change)", y="-log10(p.adj)",
       title=paste0("Volcano: ", group1, " vs ", group2)) +
  theme_bw() +
  theme(legend.position="none", text=element_text(size=14))

ggsave(file.path(output_dir, paste0("volcano_plot_", group1, "_vs_", group2,".png")), plot=p, width=6, height=5, dpi=300)

# =========================
# 11. Finish
# =========================
message("✅ eSLAC preprocessing and analysis completed successfully.")
message("Output directory: ", output_dir)
message("Session Info:")
print(sessionInfo())
