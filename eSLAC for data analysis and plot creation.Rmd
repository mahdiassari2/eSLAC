#!/usr/bin/env Rscript
# eSLAC preprocessing & analysis
# Author: Mahdi Assari
# Repo:   https://github.com/mahdiassari2/eSLAC
# License: MIT
# -------------------------------------------------------------------
# This script:
#  1) Validates env & packages (Conda-based R — no installs here)
#  2) Loads tRNA modification reference table
#  3) Indexes TSV/count files and maps them to user-friendly condition labels
#  4) Reads data in parallel (selected columns only)
#  5) Computes per-gene/per-isoacceptor counts & percentages
#  6) Computes charging metrics & between-group differences
#  7) Builds a volcano plot
# -------------------------------------------------------------------

suppressPackageStartupMessages({
  required_packages <- c(
    "tidyverse", "ggplot2", "purrr", "readxl", "foreach",
    "doParallel", "gridExtra", "ggpubr", "data.table", "stringr",
    "ggrepel", "writexl", "iterators"  # iterators needed for foreach::iter()
  )
})

# === Package / Environment checks (Conda-only) ======================
missing_packages <- setdiff(required_packages, rownames(installed.packages()))
if (length(missing_packages) > 0) {
  stop(
    paste0(
      "Missing required packages: ", paste(missing_packages, collapse = ", "),
      "\nPlease install them in Conda (no install in R):\n",
      "conda install -n rstudio_env ",
      "r-tidyverse r-ggplot2 r-readxl r-data.table r-stringr r-foreach r-doparallel ",
      "r-gridextra r-ggpubr r-writexl r-iterators"
    ),
    call. = FALSE
  )
}
invisible(lapply(required_packages, library, character.only = TRUE))
message("✅ All required packages are installed and loaded.")

# === Config ==========================================================
# Change only here for your environment / experiment naming
samplenumlist <- 1:21
mutdellim <- 5  # % threshold for mutation/deletion filtering

exclude_isoaccep         <- c("Ile-GAT", "Tyr-ATA")
AA_anticodon_N1_excluded <- c("iMet-CAT-2-1", "Val-CAC-14-1")

# Condition labels
var1  <- "(1)WT_NT";         var2  <- "(2)WT_pU";            var3  <- "(3)WT_pU+f5C"
var4  <- "(4)PUS1KO_NT";     var5  <- "(5)PUS1KO_pU";        var6  <- "(6)PUS1KO_pU_f5C"
var7  <- "(7)PUS1+-BS";      var8  <- "(8)TRUB1+-BS";        var9  <- "(9)PUS7+-BS"
var10 <- "(10)PicB-50C-3h";  var11 <- "(11)PicB-60C-3h";     var12 <- "(12)PicB-70C-3h"
var13 <- "(13)PicB-70C-2h";  var14 <- "(14)PicB-70C-1h";     var15 <- "(15)BID-50C-3h"
var16 <- "(16)BID-60C-3h";   var17 <- "(17)BID-70C-3h";      var18 <- "(18)BID-70C-2h"
var19 <- "(19)BID-70C-1h";   var20 <- "(20)NoTreat";         var21 <- "(21)BID-PicB-50C50C-1h1h"

# Paths
path1 <- "/project/taopan/mahdi"
path2 <- "/6_sam_counter"
path3 <- "/5_tsv"
path7 <- "/sinmol"

path4 <- "/MA-13-456-epichemcross"          # project subdir
path5 <- "/hg38_tRNA_HC_intro_removed_CCA_upper_case/"
path6 <- "/MA-13-456-epichemcross/"

path8               <- "/project/taopan/mahdi/jupyter_R/all_tRNA_seq_numbering_MA_20250122.xlsx"
path_mostabunlist   <- "/project/taopan/mahdi/plots/MA-13-56_PUSKO_BIDmost_abun_isodecod_list-_cytoandmito_2024-12-17.rds"

PATH_5_tsv   <- file.path(path1, sub("^/", "", paste0(path3, path4, path5)))     # TSV basewise
PATH_C       <- file.path(path1, sub("^/", "", paste0(path2, path4, path5)))     # Counts
PATH_SinMol  <- file.path(path1, sub("^/", "", paste0(path7, path6)))
output_dir   <- file.path(path1, "plots", sub("^/", "", path4))

dir.create(output_dir, showWarnings = FALSE, recursive = TRUE)

AA_anticodon_N1_N2_ofInt <- character(0)
AAofInt                  <- character(0)

# Parallel
n_cores <- max(1, parallel::detectCores() - 1)
data.table::setDTthreads(n_cores)

# Theme & helpers
theme_set(
  theme_bw() +
    theme(
      legend.position = "bottom",
      text = element_text(family = "Arial", size = 14),
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(color = "black")
    )
)
`%nin%` <- Negate(`%in%`)

# === Utility: sanity checks =========================================
stop_if_missing_dir <- function(p) {
  if (!dir.exists(p)) stop(paste0("Path not found: ", p), call. = FALSE)
}
stop_if_missing_file <- function(p) {
  if (!file.exists(p)) stop(paste0("File not found: ", p), call. = FALSE)
}

stop_if_missing_dir(PATH_5_tsv)
stop_if_missing_dir(PATH_C)
stop_if_missing_file(path8)
stop_if_missing_file(path_mostabunlist)

# === Load modification table ========================================
load_modtable <- function(path_excel) {
  mt <- read_excel(path_excel) |>
    select(1:103) |>
    mutate(across(2:103, ~na_if(., "-"))) |>
    mutate(across(2:103, ~na_if(., "."))) |>
    mutate(across(2:103, ~gsub("[tU]", "T", .))) |>
    mutate(across(2:103, ~gsub("g", "G", .))) |>
    mutate(across(2:103, ~gsub("c", "C", .))) |>
    mutate(AA_anticodon_N1 = AA) |>
    separate(AA, c("AA", "anticodon", "N1"), sep = "-", remove = TRUE) |>
    mutate(AA_anticodon = paste(AA, anticodon, sep = "-"))
  mt
}
modtable <- load_modtable(path8)

# === Index files & map to labels ====================================
index_files <- function(base_path) {
  stop_if_missing_dir(base_path)
  tibble(file_name = list.files(base_path)) |>
    filter((str_detect(file_name, "\\.tsv$") | str_detect(file_name, "\\.txt$")),
           !str_detect(file_name, "unassigned")) |>
    mutate(file_name2 = sub("(.*)\\.(tsv|txt)$", "\\1", file_name)) |>
    separate(
      file_name2,
      into = c("junk0","sample","junk2","junk3","bc","junk4","binstart","binstop","junk5"),
      sep = "_", remove = TRUE, fill = "right"
    ) |>
    select(file_name, sample, bc, binstart, binstop)
}

FILES   <- index_files(PATH_5_tsv)
FILES_C <- index_files(PATH_C)

map_samples <- function(df) {
  # Map raw "S#" + barcodes to your var# labels, then keep only rows that changed
  mapped <- df |>
    mutate(sample = case_when(
      sample == "S1"  & bc %in% c("bc1","bc2","bc3") ~ var1,
      sample == "S2"  & bc %in% c("bc1","bc2","bc3") ~ var2,
      sample == "S3"  & bc %in% c("bc1","bc2","bc3") ~ var3,
      sample == "S4"  & bc %in% c("bc4","bc5","bc6") ~ var4,
      sample == "S5"  & bc %in% c("bc4","bc5","bc6") ~ var5,
      sample == "S6"  & bc %in% c("bc4","bc5","bc6") ~ var6,
      sample == "S13" & bc %in% c("bc1","bc2","bc3") ~ var7,
      sample == "S13" & bc %in% c("bc4","bc6")       ~ var8,
      sample == "S13" & bc %in% c("bc7","bc8","bc9") ~ var9,

      sample == "S1"  & bc %in% c("bc9","bc10") ~ var10,
      sample == "S2"  & bc %in% c("bc9","bc10") ~ var11,
      sample == "S3"  & bc %in% c("bc9","bc10") ~ var12,
      sample == "S4"  & bc %in% c("bc9","bc10") ~ var13,
      sample == "S5"  & bc %in% c("bc9","bc10") ~ var14,
      sample == "S6"  & bc %in% c("bc9","bc10") ~ var15,
      sample == "S7"  & bc %in% c("bc9","bc10") ~ var16,
      sample == "S8"  & bc %in% c("bc9","bc10") ~ var17,
      sample == "S9"  & bc %in% c("bc9","bc10") ~ var18,
      sample == "S10" & bc %in% c("bc9","bc10") ~ var19,
      sample == "S11" & bc %in% c("bc9","bc10") ~ var20,
      sample == "S12" & bc %in% c("bc9","bc10") ~ var21,
      TRUE ~ sample
    ))
  mapped |> filter(sample != df$sample)  # keep only rows that were remapped
}

FILES   <- map_samples(FILES)   |>
  mutate(binstart = ifelse(is.na(binstart), -3, binstart),
         binstop  = ifelse(is.na(binstop),  -3, binstop))

FILES_C <- map_samples(FILES_C) |>
  mutate(binstart = ifelse(is.na(binstart), -3, binstart),
         binstop  = ifelse(is.na(binstop),  -3, binstop))

# === Parallel read helpers ==========================================
read_tsv_selected <- function(row, base_path, selected_columns) {
  fp <- file.path(base_path, row$file_name)
  dt <- data.table::fread(fp, sep = "\t", showProgress = FALSE)
  missing_cols <- setdiff(selected_columns, names(dt))
  if (length(missing_cols) > 0) {
    stop(paste0("Missing required columns in ", basename(fp), ": ", paste(missing_cols, collapse = ", ")))
  }
  dt <- dt[, ..selected_columns]
  dt[, `:=`(sample = row$sample, bc = row$bc, binstart = row$binstart, binstop = row$binstop)]
  dt
}

# === Read basewise TSVs (PATH_5_tsv) =================================
FILES_oneS <- FILES |> filter(substr(sample, 2, 2) %in% samplenumlist) |> as.data.table()
selected_columns <- c("gene","position","base","pileup","deletion","mutation","insertion","A","C","G","T","N")

cl <- parallel::makeCluster(n_cores)
doParallel::registerDoParallel(cl)
start_time <- Sys.time(); message("⏱ Start: ", start_time)

hg38_tRNA_t <- foreach::foreach(
  row = iter(FILES_oneS, by = "row"),
  .packages = c("data.table")
) %dopar% {
  read_tsv_selected(row, PATH_5_tsv, selected_columns)
} |> data.table::rbindlist(use.names = TRUE, fill = TRUE)

# === Read count files (PATH_C) ======================================
FILES_oneS_C <- FILES_C |> filter(substr(sample, 2, 2) %in% samplenumlist) |> as.data.table()
selected_columns_c <- c("name","count")

hg38_tRNA_c <- foreach::foreach(
  row = iter(FILES_oneS_C, by = "row"),
  .packages = c("data.table")
) %dopar% {
  # reuse reader but with different selected columns
  fp <- file.path(PATH_C, row$file_name)
  dt <- data.table::fread(fp, sep = "\t", showProgress = FALSE)
  miss <- setdiff(selected_columns_c, names(dt))
  if (length(miss) > 0) stop(paste0("Missing columns in ", basename(fp), ": ", paste(miss, collapse = ", ")))
  dt <- dt[, ..selected_columns_c]
  dt[, `:=`(sample = row$sample, bc = row$bc, binstart = row$binstart, binstop = row$binstop)]
  dt
} |> data.table::rbindlist(use.names = TRUE, fill = TRUE)

parallel::stopCluster(cl)
data.table::setnames(hg38_tRNA_c, "name", "gene")

# === Join basewise + counts =========================================
hg38_tRNA_tc <- merge(
  hg38_tRNA_t,
  hg38_tRNA_c[, .(gene, sample, bc, binstart, binstop, count)],
  by = c("gene","sample","bc","binstart","binstop"),
  all.x = TRUE, allow.cartesian = TRUE
)

# === Split tRNA vs rRNA & clean gene names ===========================
hg38_tRNA_tRNA <- hg38_tRNA_tc[
  gene %nin% c(
    "NR_004394.1","NR_002716.3","NR_003925.1","NR_004430.2","NR_002756.2",
    "NR_004391.1","NR_004392.1","NR_004393.1","NR_001571.2",
    "Homo_sapiens_chrX.rRNA-5SR5SR","Homo_sapiens_chrX.rRNA-58S58S",
    "Ecoli_Tyr","Yeast_Phe","Ecoli_Lys",
    "spikein_SCC1","spikein_SCCA1","spikein_SCCA2","spikein_SCCA3"
  )
]

hg38_tRNA_tRNA[, gene := fifelse(
  str_detect(gene, "^Homo_sapiens_tRNA-"),
  str_remove(gene, "^Homo_sapiens_tRNA-"),
  fifelse(!str_detect(gene, "-"), str_replace(gene, "(...$)", "-\\1"), gene)
)]
hg38_tRNA_tRNA[, source := ifelse(substr(gene, 1, 2) == "mt", "mitochondrial", "cytosolic")]
data.table::setnames(hg38_tRNA_tRNA, "bc", "rep")

if (length(AA_anticodon_N1_N2_ofInt) > 0) {
  hg38_tRNA_tRNA <- hg38_tRNA_tRNA[AA_anticodon_N1_N2 %in% AA_anticodon_N1_N2_ofInt]
}

# === Counts/percentages per isoacceptor/isodecoder ===================
temp_count <- hg38_tRNA_tRNA[order(position),
  .(position = first(position)),
  by = .(sample, rep, gene, source, binstart, binstop, count)
]
temp_count[, c("AA","anticodon","N1","N2") := tstrsplit(gene, "-", fixed = TRUE)]
temp_count[, AA_anticodon := paste(AA, anticodon, sep = "-")]

# totals
temp_count[, tRNA_gene_count_per_rep       := sum(count), by = .(sample, rep, gene, binstart, binstop)]
temp_count[, tRNA_gene_count_all_rep       := sum(count), by = .(sample, gene, binstart, binstop)]
temp_count[, tRNA_gene_count_per_rep_total := sum(count), by = .(sample, source, rep, binstart, binstop)]
temp_count[, tRNA_gene_percent_per_rep     := tRNA_gene_count_per_rep / tRNA_gene_count_per_rep_total * 100]
temp_count[, tRNA_gene_count_all_rep_total := sum(count), by = .(sample, source, binstart, binstop)]
temp_count[, tRNA_gene_percent_all_rep     := tRNA_gene_count_all_rep / tRNA_gene_count_all_rep_total * 100]

# isoacceptor-level shares
temp_count[, tRNA_isoaccep_count_all_rep_total := sum(count), by = .(sample, AA_anticodon, binstart, binstop)]
temp_count[, tRNA_isodecod_percent_all_rep     := tRNA_gene_count_all_rep / tRNA_isoaccep_count_all_rep_total * 100]
temp_count[, tRNA_isoaccep_count_per_rep_total := sum(count), by = .(sample, rep, AA_anticodon, binstart, binstop)]
temp_count[, tRNA_isodecod_percent_per_rep     := tRNA_gene_count_per_rep / tRNA_isoaccep_count_per_rep_total * 100]
temp_count[, repN                              := .N, by = .(sample, gene, binstart)]
temp_count[, tRNA_isodecod_percent_avg         := sum(tRNA_isodecod_percent_per_rep) / repN, by = .(sample, gene, binstart)]
temp_count[, maxisodecod_percent_avg           := max(tRNA_isodecod_percent_avg), by = .(sample, AA_anticodon, binstart)]
temp_count[, maxisodecod                       := as.integer(tRNA_isodecod_percent_avg == maxisodecod_percent_avg)]

# === Prepare ordered basewise table =================================
temp_ordered_count <- copy(hg38_tRNA_tRNA)[order(gene, sample, rep, position)]
temp_ordered_count[, c("AA","anticodon","N1","N2") := tstrsplit(gene, "-", fixed = TRUE)]
temp_ordered_count[, AA_anticodon    := paste0(AA, "-", anticodon)]
temp_ordered_count[, AA_anticodon_N1 := paste0(AA_anticodon, "-", N1)]

# === Most-abundant list & exclusions ================================
most_abund_list <- readRDS(path_mostabunlist)
most_abund_list <- most_abund_list[[1]]
most_abund_list_filtered <- most_abund_list[!substr(most_abund_list, 1, 7) %in% substr(exclude_isoaccep, 1, 7)]
most_abund_list_filtered <- substr(most_abund_list_filtered, 1, 9)

# === Example: charging computation (ACC at 5' end) ==================
temp_count_filtered <- copy(temp_ordered_count)  # <-- If you already had this upstream
setDT(temp_count_filtered)

temp_correct_proc <- temp_count_filtered[binstart == "-3"]
temp_correct_proc[, delrate      := deletion / pmax(pileup, 1)]
temp_correct_proc[, delrate_avg  := mean(delrate),  by = .(sample, binstart, AA_anticodon_N1, position)]
temp_correct_proc[, delrate_SD   := sd(delrate),    by = .(sample, binstart, AA_anticodon_N1, position)]
temp_correct_proc[, mutrate_avg  := mean(mutation), by = .(sample, binstart, AA_anticodon_N1, position)]
temp_correct_proc[, mutrate_SD   := sd(mutation),   by = .(sample, binstart, AA_anticodon_N1, position)]

# charging calls (top 3 bases “ACC”)
setorder(temp_correct_proc, -position)
temp_correct_proc_charging <- temp_correct_proc[
  , valid_charging := ifelse(paste0(head(base, 3), collapse = "") == "ACC", "yes", "no"),
  by = .(sample, binstart, AA_anticodon_N1, rep)
][valid_charging == "yes"
  , charging_ratio := pileup[1] / pmax(pileup[2], 1),
  by = .(sample, binstart, AA_anticodon_N1, rep)
]

# Collapse to one row per sample/AA_anticodon_N1 (example summary)
temp <- temp_correct_proc_charging[
  order(-position), .SD[1],
  by = .(sample, AA_anticodon_N1, rep)
][, .(
  charging_ratio_avg = mean(charging_ratio, na.rm = TRUE),
  charging_ratio_sd  = sd(charging_ratio,   na.rm = TRUE),
  source = first(source)
), by = .(sample, AA_anticodon_N1)]

# === Volcano example ================================================
# Prepare RPMs per isoacceptor
temp_volcano <- copy(temp_correct_proc)[binstart == "-3"]
temp_volcano <- temp_volcano[order(position), .SD[1], by = .(sample, gene, rep)]
temp_volcano[, totalSumCounts := sum(count), by = .(rep, sample)]
temp_volcano[, AA_anticodon := paste(AA, anticodon, sep = "-")]
temp_volcano[, AASumCounts  := sum(count), by = .(rep, sample, AA_anticodon)]
temp_volcano[, rpm          := AASumCounts / pmax(totalSumCounts, 1)]

# Choose two groups to compare (example)
group1 <- "4)"; group2 <- "20"
temp_volcano_norep <- temp_volcano[order(rep), .SD[1], by = .(sample, gene)]
temp_volcano_norep <- temp_volcano_norep[str_sub(sample, 2, 3) %in% c(group1, group2)]
temp_volcano_norep[, meanRPM := mean(rpm), by = .(sample, gene)]
temp_volcano_norep <- temp_volcano_norep[order(sample, gene)]

# t-test per gene
temp_volcano_ttest <- temp_volcano[str_sub(sample, 2, 3) %in% c(group1, group2)][
  , if (length(unique(sample)) == 2 && all(table(sample) >= 2)) {
      .(p.value = t.test(rpm ~ sample)$p.value)
    } else .(p.value = NA_real_),
  by = gene
][, p.adj := p.adjust(p.value, method = "BH")]

temp_volcano_norep <- temp_volcano_norep[, .(meanRPM = mean(meanRPM)), by = .(sample, gene)]
temp_volcano_norep <- temp_volcano_norep |>
  pivot_wider(names_from = sample, values_from = meanRPM)

# Resolve labels “(x)” to x for title
sam1 <- ifelse(str_sub(group1, -1, -1) == ")", str_sub(group1, 1, 1), group1)
sam2 <- ifelse(str_sub(group2, -1, -1) == ")", str_sub(group2, 1, 1), group2)

# logFC + p.adj
merged <- temp_volcano_norep |>
  left_join(temp_volcano_ttest, by = "gene") |>
  mutate(
    logFC = log2((!!sym(names(.)[2]) + 1e-9) / (!!sym(names(.)[3]) + 1e-9)) # prevent div by zero
  )

# Plot
maxy <- 5; xlim_range <- 3; logFC_line <- 1.5; pvalue_line <- 0.05
p <- ggplot(merged, aes(x = logFC, y = -log10(p.adj))) +
  geom_point(size = 2, alpha = 0.5) +
  geom_text(
    data = subset(merged, (logFC > log2(logFC_line) & -log10(p.adj) > -log10(pvalue_line)) |
                        (logFC < -log2(logFC_line) & -log10(p.adj) > -log10(pvalue_line))),
    aes(label = gene), vjust = -0.5, size = 2
  ) +
  geom_vline(xintercept = c(-log2(logFC_line), log2(logFC_line)), lty = 2) +
  geom_hline(yintercept = -log10(pvalue_line), lty = 2) +
  coord_cartesian(xlim = c(-xlim_range, xlim_range), ylim = c(0, maxy)) +
  labs(x = "log2(Fold Change)", y = "-log10(p.adj)",
       title = paste0("Volcano plot_", get(paste0("var", sam1)), " / ", get(paste0("var", sam2)))) +
  theme(
    text = element_text(size = 18, color = "black"),
    axis.text = element_text(size = 14, color = "black"),
    panel.background = element_rect(colour = "black"),
    legend.position = "none"
  )

outfile <- file.path(output_dir, paste0(
  "nocol_padj_volcanoplot_", "_", group1, "_", group2, "_", Sys.Date(), ".png"
))
ggsave(outfile, plot = p, width = 5, height = 5, dpi = 300)

end_time <- Sys.time()
message("⏱ End:   ", end_time)
message("⏱ Took:  ", format(end_time - start_time))

# Optional: session info for reproducibility
message("\n--- Session Info ---")
print(sessionInfo())
